---
layout:     post
title:   java垃圾回收全复习
subtitle:  今天面试的时候这个点忘掉了
date:       2018-12-24
author:     Pony
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - java
    - 垃圾回收（Garbage Collector）
---

>下午遇到一个很厉害的面试官，聊这个，只知道一星半点儿，再深层次就不知道了，准备做一个比较全面的笔记。flag立好了。

##概念篇：
### 为什么要执行垃圾回收，回收的是哪一块位置?
堆内存，是jvm启动时创建的，用来**维护运行时的数据**，主要存放创建的`对象`和`数组`，如果我们动态创建对象，没有得到及时的处理，导致堆空间被占满，内存溢出。
因此java提供一种垃圾回收机制，在`后台创建一个守护进程`，会在`内存紧张的时候自动跳出来`，进行回收。
### 什么是垃圾？
垃圾:`不再存活的对象`
### 如何判断是不是垃圾？
通常有2中方法判断是否存活:
1. 引用计数法
2. 可达性分析法(可以到达的对象)

## 判断是不是垃圾的方法
### 引用计数法
#### 过程
每`创建一个对象`就会分配一个`引用计数器`，用来*记录该对象被引用的个数*，如果为0，就意味着是`死亡对象`，就会被回收。
#### 缺点
如果2个对象`互持对方的引用`，哪怕不被外接任何对象引用，他们的计数不为0，导致不会被回收，实际上，已经不会再被用到了。

#### 结论
java不会采用这种方案
### 可达性分析法
是目前主流的语言判断对象是否存活的方法。
#### 过程
基本思路：把所有应用对象看成一棵树，java中有4种类型的对象是树根。从根节点GC Roots出发，持续遍历出所有相关联的树枝对象，`这些可以到达的对象称为可达对象`，也就是存活的对象，`其余不可达的对象`就是垃圾。
![image](https://ws4.sinaimg.cn/large/006tNbRwly1fyjdvu9x0bj30cx08z74f.jpg)

#### java中4种GC Roots类型：
* 虚拟机栈（帧栈中的本地变量表）中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中 JNI 引用的对象。


## 回收垃圾的方式
下图是未被垃圾回收的堆内存：
![image](https://ws1.sinaimg.cn/large/006tNbRwly1fyjecopfp8j30ou070dgo.jpg)
>黑色：垃圾
>灰色：对象
>绿色：空白空间




### 标记-清理
>所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记。
>>
第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接 清空 即可。

得到下面的空间：
![image](https://ws1.sinaimg.cn/large/006tNbRwly1fyjehj2ojkj30oq072gn6.jpg)
#### 缺点
产生内存碎片
### 标记-整理
在清理的时候，把所有 存活 对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。
![image](https://ws2.sinaimg.cn/large/006tNbRwly1fyjf59pw06j30s207kwf3.jpg)


`标记-清理`和`标记-整理`这两种方案适合 存活对象多，垃圾少 的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。
### 复制
把内存空间分成2半，1/2,一段时间只允许在一块上面进行分配，`当这一块内存被分配完后`，则`执行垃圾回收`：`把所有存活的对象复制在另一个内存上`，然后`把这个当前内存直接全部清除`
![image](https://ws1.sinaimg.cn/large/006tNbRwly1fyjf67f97jj30ns0ec0tt.jpg)

#### 缺点
在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的 复制清空。
#### 优点
这种做法不容易产生碎片，也简单粗暴；

## java的分代回收机制
###堆结构
一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：

* 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成 不可达 的对象，快速死去 ，因此这块区域的特点是 存活对象少，垃圾多 。形象点描述这块区域为： `新生代`；
* 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些 存活时间较长 的对象放在一起，它们的特点是 存活对象多，垃圾少 。形象点描述这块区域为： `老年代`；
* ~~永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：`永久代` 。（不过在 Java 8 里已经把 永久代 删除了，把这块内存空间给了`元空间`）~~

也就是说，常规的 Java 堆至少包括了 `新生代` 和 `老年代` 两块内存区域，而且这两块区域有很明显的特征：

* 新生代：**存活对象少、垃圾多**
* 老年代：**存活对象多、垃圾少**

## jvm回收方案
### 新生代--复制回收机制
因为每次GC的时候，都会有大量新对象死去，少量存活。
**因此采用 复制 回收算法**
那么如何设计这个 复制 算法比较好呢？有以下几种方式：

####方案1： 把内存均分成 1:1 两等份
![](https://ws1.sinaimg.cn/large/006tNbRwly1fyjfmsh771j30io0ca0t9.jpg)
每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。

缺点：
>相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。

####方案2： 把内存均分成 9:1 两等份
![](https://ws4.sinaimg.cn/large/006tNbRwly1fyjfpppe9lj30j80dujs1.jpg)
最开始在 9 的内存区使用，当 9 快要满时，执行复制回收，把 9 内仍然存活的对象复制到 1 区，并清空 9 区。

缺点：
>当把9区的存活对象复制到1区的时候，有可能1区不够放，就会把多的放到`老年区`，这样就破坏了老年区的规则。老年区并不全部存放的是老年对象。

####方案3： 把内存均分成 8:1:1 三等份
![](https://ws1.sinaimg.cn/large/006tNbRwly1fyjft1e124j30km0didgl.jpg)

定义：
8:1:1 3个区分别称为eden(伊甸园)，SurvivorA,SurvivorB。eden新生对象在里创建，Survivor为经历GC后存活下来的对象。
过程：
1. 首先，Eden区最大，对外提供堆内存。当 Eden 区快要满了，则进行 Minor GC，把存活对象放入 Survivor A 区，清空 Eden 区；
2. Eden区被清空后，继续对外提供堆内存；
3. 当 Eden 区再次被填满，此时对 Eden 区和 Survivor A 区同时进行 Minor GC，把存活对象放入 Survivor B 区，同时清空 Eden 区和Survivor A 区；
4. Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把 Eden 区和某个 Survivor 区的存活对象放到另一个 Survivor 区；
5. 当某个 Survivor 区被填满，`且仍有对象未被复制完毕时`，或者`某些对象在反复 Survive 15 次左右时`，则把这部分剩余对象放到`Old 区`；
6. 当 Old 区也被填满时，进行 Major GC，对 Old 区进行垃圾回收。

### 老年代－标记整理 回收机制
老年代存放的是时间久的对象，每次GC后，存活对象还比较多，少部分被回收。
所以选择标记整理回收机制。还不会存在内存碎片化。