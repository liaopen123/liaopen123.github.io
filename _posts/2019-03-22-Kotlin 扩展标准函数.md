---
layout:     post
title:  Kotlin 扩展标准函数
subtitle: let apply run with also repeat takeIf takeUnless  添加一下实际运运用场景
date:     2019-03-22
author:     Pony
header-img: img/post-bg-mayday-bubble.jpg
catalog: true
tags:
    - Kotlin
---


很久没有更新了，最近主要忙于熟悉项目和重新搭建项目。终于做完首页的几个page，于是轻松了一些。每次用到kotlin的时候，都会想到这几个关键字，之前有总结过，只不过笔记找不到了，现在重新记录一次。

##作用域函数
`let`,`apply`,`run`,`with`,`also`,对于他们几个来说最重要的功能是在调用函数的内部又提供了一个`作用域`。
选择作用域中`it`或者`this`的函数，更具具体需求，如果不想覆盖`作用域外部`的`this`,这个时候用`it`更加合适。

### let

1. block中`it`指对象本身，可以在block中继续相关操作。
2. 返回值 是语句的最后一行，如果最后一句无返回值，则整个let语句也无返回值。
用法:

```kotlin
var change = list.let{
it.add("a")
it.add("b")

"hello"
}

println(list)//["a","b"]
println(change) //“hello”
```


### apply
如果遇到对`同一个对象`,做很多次操作的情况，适合用**apply**。
1. 必有返回值，返回值是本身
2. 内部block不需要用`it`代指，直接this表示本体。
用法:


```kotlin
list2 = list.apply{
    add("c")
    add("d")
}
println(list)//["a","b","c","d"]
println(list2)//["a","b","c","d"]
```
实际运用:
```kotlin
/**************************java*****************************/
Intent intent = new Intent(this, Activity1.class);
intent.setAction("actionA");
Bundle bundle = new Bundle();
bundle.putString("content","hello");
bundle.putString("sender","taylor");
intent.putExtras(bundle);
startActivity(intent);
/****************************kotlin**********************/

 Intent(this,MainActivity::class.java).apply { 
            action = "actionA"
            putExtras(Bundle().apply { 
                putString("content","hello")
                putString("content2","hello2")
            })
            
            startActivity(this)
        }
```

### run

目前对于这个run函数看起来貌似没有什么用处，但是在run函数当中它不仅仅只是一个作用域，他还有一个返回值。他会返回在这个作用域当中的最后一个对象。

例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑。
1. 相当于`let`和`apply`的结合体
2. 返回值 是语句的最后一行，如果最后一句无返回值，则整个run语句也无返回值。
3. 内部`this`指代

```kotlin
//写法1
change = list.run{
add("e")
add("f")
"world"
}
println(list)//["a","b","c","d","e","f"]
println(change)//"world"

//写法2
run{
    if(login) awardsDialog else loginDialog
}.show()
//可以看到上面这段代码会变得更加的简洁，并且可以将show方法一次应用到上面两个dialog当中，而不是去调用两次。
```


### with

`with`和`run`的作用一样，只是写法不一样。

```kotlin
var change = with(list){
add("g")
add("h")
"lph"
}
println(list)//["a","b","c","d","e","f",,"g","h"]
println(change)//"lph"


//实际运用：
   with(WebView(this).settings) {
            javaScriptEnabled = true
            databaseEnabled = true
        }
     //对比 run   
        webView.settings.run { 
 javaScriptEnabled = true
 databaseEnabled = true
}

//如果setting可能为null 则 下面的写法会更好 在函数执行前 会先对函数进行检查
webView.settings?.run { 
 javaScriptEnabled = true
 databaseEnabled = true
}
```


### also

also和apply相似。作用域中用`it`表示对象，返回值是本身。

```kotlin
        list.also {
            it.add("hello world")
        }
```



### repeat
重复执行作用域中的代码 
```kotlin
   repeat(10) {
            println("我是第${it}次")
        }
```

### takeIf
//作用域中最后一行返回的为一个`boolean`类型。如果为`true`，则引用为本身(`demo中myself 值为"helloworld"`)，如果最后一行的返回值为`false`,则返回值为**`null`**。
```kotlin
   val myself = "helloworld".takeIf {
            it.length > 1
        }
        print(myself)
```

### takeUnless
//和takeIf作用相反，作用域中最后一行返回的为一个`boolean`类型。如果为`true`，则引用为`null`，如果最后一行的返回值为`false`,则返回值为本身(`demo中myself 值为"helloworld"`)。
```kotlin
   val myself = "helloworld".takeIf {
            it.length > 1
        }
        print(myself)
```
如果不知道怎么选择，可以通过这个流程图来选择：
![](https://ws1.sinaimg.cn/large/006tKfTcly1g1bnlp5faqj30fa06g74w.jpg)
![](https://ws4.sinaimg.cn/large/006tKfTcly1g1bnntd6mpj30sa0jgae0.jpg)

### 在作用域中返回值的类型
在这些作用域中它们都会存在一个返回值。在上面的讲述的run,with,T.run,T.let中它们返回的都是作用域中最后一个对象。当然它们所返回的值是允许和接受者it或者this对象的类型不同。但是并不是所有的标准函数都是返回作用域的最后一个对象。例如T.also函数。
```kotlin
val original = "abc"
original.let {
 println("The original String is $it") // "abc"
 it.reversed() 
}.let {
 println("The reverse String is $it") // "cba"
 it.length 
}.let {
 println("The length of the String is $it") // 3
}

original.also {
 println("The original String is $it") // "abc"
 it.reversed() 
}.also {
 println("The reverse String is ${it}") // "abc"
 it.length 
}.also {
 println("The length of the String is ${it}") // "abc"
}
```
实际运用场景：
```kotlin
//原始函数
fun makeDir(path: String): File {
 val result = File(path)
 result.mkdirs()
 return result
}

//通过let和also的链式调用改进后的函数
fun makeDir(path: String) = path.let{ File(it) }.also{ it.mkdirs() }
```

## 总结

在这里做一下总结，我们可以看出在这五个通用标准函数当中它们的特性也是十分的简单，无非也就是接收者和返回值的不同。对于with,T.run,T.apply接收者是this，而T.let和T.also接受者是it；对于with,T.run,T.let返回值是作用域的最后一个对象（this）,而T.apply和T.also返回值是调用者本身(itself)。

#### 参考文章
[Kotlin 中的 run、let、with、apply、also、takeIf、takeUnless 语法糖使用和原理分析](https://www.jianshu.com/p/e1730ff522af)
[Kotlin中标准函数run、with、let、also与apply的使用和区别详解](https://www.jb51.net/article/137056.htm)