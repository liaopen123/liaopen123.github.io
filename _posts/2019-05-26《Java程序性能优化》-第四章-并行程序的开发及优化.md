---
layout:     post
title:  《Java程序性能优化》-第四章
subtitle: 并行程序的开发及优化
date:     2019-05-26
author:     Pony
header-img: img/post-bg-mayday-bubble.jpg
catalog: true
tags:
    - 并行程序
---

需要巩固的知识点:
    * 多线程设计模式,如`Future模式`，`Master-Worker`,`Guarded Suspeionsion`模式，不变模式和生产者，消费者模式。
    * jdk内置的多线程框架和各种线程池
    * jdk内置的并发数据结构
    * java并发控制方式
    * 锁的优化
    * 使用无锁的方式提高并发性能
    * 使用轻量级的协程获得更高的并行度。

## 多线程设计模式
### Future模式
核心思想是：
1. **创建子线程**获取慢的对象，先返回一个壳(代理类),壳.getData()获取数据的时候，一直在wait()，当真真正正的RealData数据得到的时候，调用壳.setData()方法，然后使一直wait的getData()不再wait(),直接返回真正的数据。

具体的流程:
我白话文写一下啊:
1. Data nameData = client.request("name");//这个开始请求数据 client 内部的request方法，分别创建了FutureData对象和RealData对象.

 2. 只不过，直接返回了FutureData对象，然后调用FutureData#getResult()这个方法已在在wait()等。真正的数据对象RealData构建很慢，只不过一构建完，就马上调用了  futureData.setRealData(realData);//setRealData方法传递真正的数据值给futureData，并且改变标识符，使一直等待的FutureData#getResult()返回真正的数据。

```java
  public class MainFuture {

    public void doIt() {
        Client client = new Client();
        Data nameData = client.request("name");
        System.out.println("请求完毕");
        synchronized (Thread.currentThread()) {
            try {
                Thread.sleep(2000);  //模拟做了其他的一些复杂的其他操作 干别的活去了
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("请求完毕:" + nameData.getResult()); //getResult 是阻塞的方法  只不过在单独的线程中调用。

        }
    }
}  
```

业务类：

```java

//Data.java  接口类  用于个RealData和FutureData去实现
interface Data {
    public String getResult();
}
//代理类，先同步返回一个空壳，调用获取数据的方法，一直wait，拿到数据就不wait了直接返回。
class FutureData implements Data {
    protected RealData realData = null;
    protected boolean isReady = false;
    public synchronized void setRealData(RealData realData) {
        if (isReady) {
            return;
        }
        this.realData = realData;
        isReady = true;
        notifyAll();
    }
    @Override
    public String getResult() {
        while (!isReady) {
            synchronized (Thread.currentThread()) {
                try {
                    Thread.currentThread().wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        return realData.getResult();
    }
}

//真正的数据类
class RealData {
    protected String result;

    public RealData(String queryStr) {
        //这里是真正的获取数据的地方 时间比较长
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i < 10; i++) {

            stringBuffer.append(queryStr);
            synchronized (Thread.currentThread()) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        result = stringBuffer.toString();
    }

    public String getResult() {
        return result;
    }
}


//核心的操作类:
public class Client {

    public Data request(final String queryStr){
        final FutureData futureData = new FutureData();
        new Thread(){
            @Override
            public void run() {
                RealData realData = new RealData(queryStr); //真真正正的很慢的操作在这里 已在在构建  这个方法执行的慢 要等很久
                futureData.setRealData(realData);//当拿到数据 就去唤醒
            }
        }.start();

        return futureData;
    }
}
```