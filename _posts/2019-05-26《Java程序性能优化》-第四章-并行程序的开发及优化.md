---
layout:     post
title:  《Java程序性能优化》-第四章(未完成..)
subtitle: 并行程序的开发及优化
date:     2019-05-26
author:     Pony
header-img: img/post-bg-mayday-bubble.jpg
catalog: true
tags:
    - 并行程序
---

需要巩固的知识点:
* 多线程设计模式,如`Future模式`，`Master-Worker`,`Guarded Suspeionsion`模式，不变模式和生产者，消费者模式。
* jdk内置的多线程框架和各种线程池
* jdk内置的并发数据结构
* java并发控制方式
* 锁的优化
* 使用无锁的方式提高并发性能
* 使用轻量级的协程获得更高的并行度。

## 多线程设计模式
### Future模式
核心思想是：
1. **创建子线程**获取慢的对象，先返回一个壳(代理类),壳.getData()获取数据的时候，一直在wait()，当真真正正的RealData数据得到的时候，调用壳.setData()方法，然后使一直wait的getData()不再wait(),直接返回真正的数据。

解决什么样的问题:
为了去除主函数中等待时间，使原有等待的时间去做其他的业务逻辑。从而充分利用计算机资源。
具体的流程:
我白话文写一下啊:
1. Data nameData = client.request("name");//这个开始请求数据 client 内部的request方法，分别创建了FutureData对象和RealData对象.

 2. 只不过，直接返回了FutureData对象，然后调用FutureData#getResult()这个方法已在在wait()等。真正的数据对象RealData构建很慢，只不过一构建完，就马上调用了  futureData.setRealData(realData);//setRealData方法传递真正的数据值给futureData，并且改变标识符，使一直等待的FutureData#getResult()返回真正的数据。

```java
  public class MainFuture {

    public void doIt() {
        Client client = new Client();
        Data nameData = client.request("name");
        System.out.println("请求完毕");
        synchronized (Thread.currentThread()) {
            try {
                Thread.sleep(2000);  //模拟做了其他的一些复杂的其他操作 干别的活去了
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("请求完毕:" + nameData.getResult()); //getResult 是阻塞的方法  只不过在单独的线程中调用。

        }
    }
}  
```

业务类：

```java

//Data.java  接口类  用于个RealData和FutureData去实现
interface Data {
    public String getResult();
}
//代理类，先同步返回一个空壳，调用获取数据的方法，一直wait，拿到数据就不wait了直接返回。
class FutureData implements Data {
    protected RealData realData = null;
    protected boolean isReady = false;
    public synchronized void setRealData(RealData realData) {
        if (isReady) {
            return;
        }
        this.realData = realData;
        isReady = true;
        notifyAll();
    }
    @Override
    public String getResult() {
        while (!isReady) {
            synchronized (Thread.currentThread()) {
                try {
                    Thread.currentThread().wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        return realData.getResult();
    }
}

//真正的数据类
class RealData {
    protected String result;

    public RealData(String queryStr) {
        //这里是真正的获取数据的地方 时间比较长
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i < 10; i++) {

            stringBuffer.append(queryStr);
            synchronized (Thread.currentThread()) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        result = stringBuffer.toString();
    }

    public String getResult() {
        return result;
    }
}


//核心的操作类:
public class Client {

    public Data request(final String queryStr){
        final FutureData futureData = new FutureData();
        new Thread(){
            @Override
            public void run() {
                RealData realData = new RealData(queryStr); //真真正正的很慢的操作在这里 已在在构建  这个方法执行的慢 要等很久
                futureData.setRealData(realData);//当拿到数据 就去唤醒
            }
        }.start();

        return futureData;
    }
}
```
#### java 类的实现
```java
public class JRealData implements Callable<String> {

    private String paras;

    public JRealData(String paras) {
        this.paras = paras;
    }

    @Override
    public String call() throws Exception {

        //这里是真正的获取数据的地方 时间比较长
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i < 10; i++) {

            stringBuffer.append(paras);
            synchronized (Thread.currentThread()) {
                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }


        }

        return stringBuffer.toString();
    }

}
//调用:
    public void doWithJdk(){
        FutureTask<String> futureTask = new FutureTask<>(new JRealData("lph"));
        ExecutorService executor = Executors.newFixedThreadPool(1);

        executor.submit(futureTask);
        //做延时操作
        System.out.println("请求完毕");
        synchronized (Thread.currentThread()) {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            System.out.println("请求完毕:" + futureTask.get()); //future getRealData一直在等realdata拿到数据wait()
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
```

### Master-Worker模式
#### 作用
把串行任务变成并行任务的方法。如果有需要可以不用等到所有结果返回，只需要根据有部分的结果进行处理。
#### 核心思想
* Master:用于接收和分配任务
    * taskQueue 任务数
    * workerQueue 执行工作的worker
    * resultQueue 用于从taskQueue**poll**出task,执行完后，把结果放入resultQueue中去。

* Worker:负责完成子任务。
    * setWorkQueue:attach to taskQueue
    * setResultMap:attach to resultQueue
    * Runnable#run(),从taskQueue**poll**出task,执行完后，把结果放入resultQueue中去。

调用处：
```java
while(没有完成||resultQueue.size()>0){
就开始拿结果
}
```    

代码展示:
    
```java
public class Master {
    //任务队列
    protected Queue<Object> taskQueue = new ConcurrentLinkedDeque<Object>();
    //worker队列
    protected Map<String, Thread> wokerMap = new HashMap<String, Thread>();
    //任务队列
    protected Map<String, Object> resultMap = new ConcurrentHashMap<String, Object>();


    public Master(Worker worker, int countWorker) {
        worker.setWorkQueue(taskQueue);
        worker.setResultMap(resultMap);

        for (int i = 0; i < countWorker; i++) {
            //一共5个thread
            wokerMap.put(Integer.toString(i), new Thread(worker, Integer.toString(i)));
        }
    }

    // call 100 times
    public void submit(Object job) {
        taskQueue.add(job);
    }


    public Map<String, Object> getResultMap() {
        return resultMap;
    }

    public void execute() {
        for (Map.Entry<String, Thread> entry : wokerMap.entrySet()) {
            entry.getValue().start();
        }
    }

    public boolean isCompete() {
        for (Map.Entry<String, Thread> entry : wokerMap.entrySet()) {
            if (entry.getValue().getState() != Thread.State.TERMINATED) {
                return false;
            }

        }
        return true;
    }
}


//worker
class Worker implements Runnable {
    //任务队列  用于取得子任务
    protected Queue<Object> workQueue;
    //子任务处理结果集
    protected Map<String, Object> resultMap;

    public void setWorkQueue(Queue<Object> workQueue) {
        this.workQueue = workQueue;
    }

    public void setResultMap(Map<String, Object> resultMap) {
        this.resultMap = resultMap;
    }


    //从工作队列中取出 并计算  并把结果放入到结果队列
    @Override
    public void run() {

        while (true) {
            Object input = workQueue.poll();//从队列中取出并删除第一个元素
            if (input == null) break;
            Object result = handle(input);

            //将处理结果写入结果集
            resultMap.put(Integer.toString(input.hashCode()), result);
        }


    }

    /**
     * 子任务具体实现的业务逻辑
     *
     * @param input
     * @return
     */
    public Object handle(Object input) {
        return input;
    }


}


//call 调用:
public void  doIt(){
    Master master = new Master(new PlusWorker(), 5); //5个worker
    for (int i = 0; i < 101; i++) {
        master.submit(i);//100个子任务
    }
    master.execute();
    int result = 0;
    Map<String, Object> resultMap = master.getResultMap();
    //只要没有完成 就一直不停的调用
    while (resultMap.size()>0||!master.isCompete()){
        Set<String> keys = resultMap.keySet();
        String key  =null;
        for (String k:keys) {
            key = k;
            break;
        }
        Integer i =null;
        if (key != null) {
            i = (Integer) resultMap.get(key);

        }

        if (i != null) {
            result+=i;
        }

        if (key != null) {
            resultMap.remove(key);
        }
    }

    System.out.println("最后的计算结果"+result);
}
}
```

