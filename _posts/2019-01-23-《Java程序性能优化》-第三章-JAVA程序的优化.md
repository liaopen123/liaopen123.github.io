---
layout:     post
title:  《Java程序性能优化》-第三章
subtitle: JAVA程序的优化
date:     2019-01-21
author:     Pony
header-img: img/post-bg-mayday-bubble.jpg
catalog: true
tags:
    - String字符串优化
    - 数据结构
    - I/O
    - 引用类型
---

##字符串优化处理
### String底层
Java中的字符串底层还是使用`char`。但对`char`进行了延伸和进一步封装。
其基本组成:
![](https://ws1.sinaimg.cn/large/006tNc79ly1fzgat7q78rj30g405qmxv.jpg)
`char[]`是字符串真正内容的超集合。想要得到字符串真正的内容，还需要通过`offset`偏移量和`count`长度，这两个要素，才能共同确定字符串的内容。

### 字符串特点 
####1.不变性
不变性是指，字符串这个`对象`,一旦生成，这个对象就不可改变(immutable)，这样的好处是针对多线程共享并且频繁访问这个对象的时候，可以省略同步和锁，从而提高系统性能。
####2. 针对常量池的优化
当两个字符串对象拥有相同的值时候，他们只引用常连池中的同一个copy。
```java
      String s1 = "123";
        String s2 = "123";
        String s3 = new String("123");
        String s4 = s3.intern();

        Log.e(TAG,""+(s1==s2));//true
        Log.e(TAG,""+(s1==s3));//false
        Log.e(TAG,""+(s1==s4));//true
```
s1和s2引用了相同的地址，s3开辟了一块堆内存空间，但它所指向的实体其实和s1,s2完全一样，可以通过`intern()`,返回在常量池中的引用。
![](https://ws3.sinaimg.cn/large/006tNc79ly1fzgbqfe4pkj30au041my2.jpg)


####3.final的定义
`String`类被`final`主要从系统安全性保护出发，不可能有任何子类。
### `subString()`引起的内存泄漏(JDK1.7已经修复)
还是大概聊聊这个吧 虽然已经修复了。
JDK1.6的`subString()`源码:
```java
public String substring(int beginIndex, int endIndex) {
	return ((beginIndex == 0) && (endIndex == count)) ? this :
	    new String(offset + beginIndex, endIndex - beginIndex, value);
    }
```
它最后调用了String的构造方法。这种实现还在引用着原先字符串变量的value[]，这让JVM误以为还在引用，导致内存泄漏。
解决办法：
```java
return new String("ttt".SubString())
```
这样就可以解决内存泄漏问题。

JDK1.7的`subString()`源码:
```JAVA
    public String substring(int beginIndex, int endIndex) {
        // Android-changed: Use native fastSubstring instead of String constructor.
        return ((beginIndex == 0) && (endIndex == length())) ? this
                : fastSubstring(beginIndex, subLen);
    }
```
其中`fastSubString()`为native方法。
### 切割和查找字符串
#### 切割字符串的三种方法
##### String#Split()
API:
```java
public String[] split(String regex)
```
特点：api简单，功能强大，但在性能敏感的地方使用，还是不可取的。

##### StringTokenizer`(标记器)`
StringTokenizer是专门由于切割字符串的。
API:
```JAVA
public StringTokenizer(String orgStr,String delim)
```
使用：
```java
   public static void StringTokenizerUse(){
       String s1= "a:b:c:d:e:f";
        StringTokenizer stringTokenizer = new StringTokenizer(s1, ":");
       while(stringTokenizer.hasMoreTokens()){
           String s = stringTokenizer.nextToken();
           Log.e(TAG,s);//true
       }
    }
```
其效率高于split()方法

##### 手动完成切割
主要通过`subString()`(空间换时间)和`indexOf()`。
代码演示：
![](https://ws4.sinaimg.cn/large/006tNc79ly1fzgoqh3fb8j30f403atb6.jpg)
##### 三种切割对比：
split()最为强大，但效率低
StringTokenizer优于split(),但是可读性较差。
自己写的 性能最好，可读性较差。

####字符串查找`charAt()`
`charAt(int index)`效率最高，远高于`starWith()`,`endWith`


