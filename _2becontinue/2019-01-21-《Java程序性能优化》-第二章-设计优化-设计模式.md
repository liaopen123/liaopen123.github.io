---
layout:     post
title:  《Java程序性能优化》-第二章
subtitle: 设计优化-设计模式
date:     2019-01-21
author:     Pony
header-img: img/post-bg-mayday-bubble.jpg
catalog: true
tags:
    - 设计模式
---

## 设计模式
### 单例模式
它是一种对象创建模式，保证一个程序中只生成一个实例，它有2个好处：
1. 减少了创建对象过程的时间消耗
2. 对于GC，减少了GC垃圾回收频率，降低了内存占中。


#### 使用
对于系统的关键组件，频繁使用的对象，单例模式可以有效的提高系统的性能。
#### 结构

| 角色 | 作用 |
| :-: | :-: |
| 单例类 | 用来提供单例的工厂 |
| Main | 使用者 |

#### 实现
写法1：
```java
public class SingleInstance01 {
    private  String TAG  =getClass().getSimpleName();
    public  static String abc = "abc";
    private SingleInstance01(){
        Log.e(TAG,"初始化");
    }
    private  static  SingleInstance01 mInstance =  new SingleInstance01();

    public SingleInstance01 getInstance(){
        return mInstance;
    }
}
```
1. 构造方法私有化
2. 对象静态

这种写法可以实现单例，但是无法控制对象生成的时机，不能进行延迟加载。这种写法，在初始化阶段便生成对象。造成资源的浪费。

进阶2：
```java
public class SingleInstance02 {
    private  String TAG  =getClass().getSimpleName();
    public  static String abc = "abc";
    private SingleInstance02(){
        Log.e(TAG,"初始化");
    }

    private  static SingleInstance02 mInstance = null;

    public static synchronized SingleInstance02 getInstance(){
        if (mInstance == null) {
            mInstance = new SingleInstance02();
        }
        return mInstance;
    }
    public void sayHello(){
        Log.e(TAG,"sayHello");
    }
}
```
好处：可以在使用时候才生成对象，避免了初始化阶段就生成对象的缺点。
坏处：由于有锁去防止多线程重复生成对象，但带来了`耗时`的缺点。

进阶3：
```java
public class SingleInstance03 {
    private  String TAG  =getClass().getSimpleName();
    public  static String abc = "abc";
    private SingleInstance03(){
        Log.e(TAG,"初始化");
    }

    private static class SingleTonHolder{
        private static SingleInstance03 mInstance = new SingleInstance03();
    }

    public static SingleInstance03 getInstance(){
        return SingleTonHolder.mInstance;
    }
    public void sayHello(){
        Log.e(TAG,"sayHello");
    }
}
```
>补充：**静态内部类的加载和外部类加载无关。静态内部类和非静态内部类一样，都是在被调用时才会被加载**(相当于两个独立的类，不存在依赖关系。)

使用静态内部类，实例的创建是在类加载的时候就完成了。使用对多线程友好。所以也不需要`syschronized`修饰。

>补充2:序列号和反序列会破坏单例，但使用场景不多，如果遇到，请注意。


### 代理模式
代理模式作用：屏蔽用户对真正对象的直接操作，通过代理访问。
#### 应用：
处于安全原因，屏蔽客户端直接访问真实对象。
#### 参与结构：
| 角色 | 作用 |
| :-: | :-: |
| 主题接口 | 让真实主题和代理类共同实现公共对外的方法。代理类代理真实主题 |
| 真实主题 | 真正实现业务逻辑的类 |
| 代理类 | 用来代理证实主题的类 |
| Main | 使用者 |

#### 实现
使用给代理模式实现`延迟加载`的方法。
```java
public interface IDBQuery {
    String query();
}

//真正执行者
class RealDBQuery :IDBQuery{
    override fun query(): String {
        return "get content"
    }
}

//代理类
class DBQueryProxy :IDBQuery{
    private  var realDBQuery: RealDBQuery? = null

    override fun query(): String {
        if(realDBQuery==null){//懒加载当用的时候才进行加载
            realDBQuery = RealDBQuery()
        }
        return realDBQuery!!.query()
    }
//main调用:
var content:String = DBQueryProxy().query()
}
```
代理类实现`延迟加载`，可以有效的提升系统启动的速度。

### 动态代理
是指代理类的字节码，在运行时期才生成，并载入当前的ClassLoder。
#### 好处：
避免了静态代理的一下缺点：
1. 避免了代理类和真正实现类实现同一个接口的操作。
2. 如果接口方法过多，代理类需要实现很多无用的方法。
3. 接口改动，真正实现类和代理类也要改动。不利于系统的维护。
4. 动态代理生成的方法绳子可以在运行时指定执行逻辑，大大提高的系统的灵活性。

####  生成动态代理的方法：
1. JDK自带:最为简单，内置，不需要引用三方。但相对于功能比较弱。
2. CGLIB：高级字节码生成库。性能比JDK强，功能十分强大。
3. Javassist：高级字节码生成库。性能比JDK强，功能十分强大。
4. ASM：低级的字节码生成工具，要求极高，使用过于繁琐，提升不高，不好维护。

####写法：

